{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quantum as a Service","text":"<p>Text about the QaaS (TBD)</p>"},{"location":"algorithms/","title":"Algorithms","text":"<p>Here we have algorithms!!!</p>"},{"location":"faqs/","title":"FAQs","text":"<p>Como se instala?</p> <p>pues asi</p>"},{"location":"get-started/","title":"Get the party started","text":"<p>Check here if you have everything up and running!</p>"},{"location":"get-started/#using-your-laptop","title":"Using your laptop","text":"<p>Do blablabla</p>"},{"location":"get-started/#using-qaas","title":"Using QaaS","text":"<p>Do the same with the QaaS user</p>"},{"location":"get-started/#using-our-emulators","title":"Using our emulators","text":"<p>dsadsadad</p>"},{"location":"get-started/#using-our-aqpus","title":"Using our aQPUs","text":"<p>dsada</p>"},{"location":"analog/sample/","title":"This is an analog algorithm","text":"<p>blablabla</p>"},{"location":"gate-based/intro_to_quantum_solutions/","title":"Introduction to digital quantum computing","text":"<p>Let's start importing qibo and the modules required for building our first circuit. We set the default numpy backend for this tutorial.</p> In\u00a0[1]: Copied! <pre>import qibo\nfrom qibo.models import Circuit\nfrom qibo import gates\n\nqibo.set_backend(\"numpy\")\n</pre> import qibo from qibo.models import Circuit from qibo import gates  qibo.set_backend(\"numpy\") <pre>[Qibo 0.2.8|INFO|2024-10-04 17:31:01]: Using numpy backend on /CPU:0\n</pre> <p>After this, we can start to do quantum circuit simulation using qibo.</p> <p>Simulating the superposition Now we can build up a simple circuit composed of one qubit and an Hadamard gate. This gate is such that, if applied to a \u22230\u27e9 state, it returns the following superposition of the fundamental states.</p> <p>At the end of the circuit we put a measurement gate, in order to be able to project the final state on the z direction and to perform a simple measurement operation.</p> In\u00a0[2]: Copied! <pre># initialize the circuit\nc = Circuit(1)\n\n# add gates\nc.add(gates.H(q=0))\nc.add(gates.M(0))\n\n# draw circuit\nprint(c.draw())\n</pre> # initialize the circuit c = Circuit(1)  # add gates c.add(gates.H(q=0)) c.add(gates.M(0))  # draw circuit print(c.draw()) <pre>q0: \u2500H\u2500M\u2500\n</pre> <p>Now we can execute the circuit 1000 times (nshots=1000), and use the simulation tool for getting the results.</p> In\u00a0[3]: Copied! <pre>simulated_final_state = c(nshots=1000)\n\nprint(simulated_final_state)\n</pre> simulated_final_state = c(nshots=1000)  print(simulated_final_state) <pre>(0.70711+0j)|0&gt; + (0.70711+0j)|1&gt;\n</pre> <p>With this execution we simulate the final state obtained applying an Hadamard gate on an initial \u22230\u27e9 state.</p> <p>Printing frequencies Now we can use the frequencies method for visualizing the obtained results. One way to do that is to activate the binary=False option; thanks to this we get a counter object which shows us how many times the two fundamental states are registered after one thousand of executions.</p> In\u00a0[4]: Copied! <pre>simulated_final_state.frequencies(binary=False)\n</pre> simulated_final_state.frequencies(binary=False) Out[4]: <pre>Counter({0: 504, 1: 496})</pre> <p>Printing probabilities Alternatively, we can use the probabilities method.</p> In\u00a0[5]: Copied! <pre># calculating probabilities\nprobabilities = simulated_final_state.probabilities\n\n# showing the two probabilities\nprint(probabilities(qubits=[0]))\n</pre> # calculating probabilities probabilities = simulated_final_state.probabilities  # showing the two probabilities print(probabilities(qubits=[0])) <pre>[0.5 0.5]\n</pre> <p>As expected, the probability of obtaining each of the two fundamental states is equal to 0.5.</p> <p>you can repeat this experiment many times, but you will always get these probabilities as results.</p> In\u00a0[6]: Copied! <pre>for _ in range(10):\n    final_state = c(nshots=1000)\n    probabilities = simulated_final_state.probabilities\n    print(probabilities(qubits=[0]))\n</pre> for _ in range(10):     final_state = c(nshots=1000)     probabilities = simulated_final_state.probabilities     print(probabilities(qubits=[0])) <pre>[0.5 0.5]\n[0.5 0.5]\n[0.5 0.5]\n[0.5 0.5]\n[0.5 0.5]\n[0.5 0.5]\n[0.5 0.5]\n[0.5 0.5]\n[0.5 0.5]\n[0.5 0.5]\n</pre> <p>If you are following the qibo tutorial from the webpage, stop here.</p> <p>Example blocks to get the code here with unrelated content:</p> <p>Note</p> <p>         If two distributions are similar, then their entropies are similar, implies the KL divergence with respect to two distributions will be smaller. And vica versa. In Variational Inference, the whole idea is to minimize KL divergence so that our approximating distribution $q(\\theta)$ can be made similar to $p(\\theta|D)$.     </p> Extra: What are latent variables? <p>     If you go about exploring any paper talking about Variational Inference, then most certainly, the papers mention about latent variables instead of parameters. The parameters are fixed quantities for the model whereas latent variables are  unobserved quantities of the model conditioned on parameters. Also, we model parameters by probability distributions. For simplicity, let's consider the running terminology of  parameters  only.     </p> <p>Warning</p> <p>         Do not miss the \"div\"     </p> <p>We will use this as a first exercise with Qibo circuits. Lets first import everything we need.</p> <ul> <li>Qibo Circuits</li> <li>Qibo Gates</li> </ul> In\u00a0[21]: Copied! <pre># Imports\n\nfrom qibo.gates import X, M\nfrom qibo.models.circuit import Circuit\n</pre> # Imports  from qibo.gates import X, M from qibo.models.circuit import Circuit In\u00a0[22]: Copied! <pre># Build the circuit. Create a circuit instance and add to it an X gate to the 0th qbit and a Meassurement to all qbits.\n\ncircuit = Circuit(nqubits=5)\ncircuit.add(X(0))\ncircuit.add(M(0, 1, 2, 3, 4))\n</pre> # Build the circuit. Create a circuit instance and add to it an X gate to the 0th qbit and a Meassurement to all qbits.  circuit = Circuit(nqubits=5) circuit.add(X(0)) circuit.add(M(0, 1, 2, 3, 4)) Out[22]: <pre>MeasurementResult(qubits=(0, 1, 2, 3, 4), nshots=0)</pre> <p>We can check the circuit using the <code>.summary()</code> and <code>.draw()</code> methods.</p> In\u00a0[23]: Copied! <pre># Look at the outputs of summary and draw infomrative methods\nprint(circuit.summary())\n</pre> # Look at the outputs of summary and draw infomrative methods print(circuit.summary()) <pre>Circuit depth = 2\nTotal number of gates = 2\nNumber of qubits = 5\nMost common gates:\nx: 1\nmeasure: 1\n</pre> In\u00a0[24]: Copied! <pre>print(circuit.draw())\n</pre> print(circuit.draw()) <pre>q0: \u2500X\u2500M\u2500\nq1: \u2500\u2500\u2500M\u2500\nq2: \u2500\u2500\u2500M\u2500\nq3: \u2500\u2500\u2500M\u2500\nq4: \u2500\u2500\u2500M\u2500\n</pre> <p>We can finally call <code>execute()</code> to simmulate the execution of the circuit. We can examine the resulting object to see that the results are the expected ones.</p> <p>For simple circuits, we expect a the results to be an instance of <code>qibo.result.CircuitResult</code>, but more complex circuits could also return a <code>qibo.result.QuantumState</code>, or a <code>qibo.result.MeasurementOutcomes</code>. Choosing a different qibo backend will also lead to different result objects. Docs are available at:</p> <ul> <li>Circuit.execute()</li> <li>CircuitResult</li> <li>QuantumState</li> <li>MeasurementOutcomes</li> </ul> In\u00a0[25]: Copied! <pre># Execute the circuit.\n\nresults = circuit.execute(nshots=1000)\ntype(results)\n</pre> # Execute the circuit.  results = circuit.execute(nshots=1000) type(results) Out[25]: <pre>qibo.result.CircuitResult</pre> <p>Several methods exist for examining the outcome of an execution. <code>frequencies()</code> counts the ocurrences of each state, <code>probabilities()</code> computes the <code>frequencies() / nshots</code> for each possible state in order, and <code>samples()</code> generates a distribution of states based on the theoretical distribution. More info on the api for each class, linked above.</p> In\u00a0[26]: Copied! <pre># Check the frequencies, probabilities and sample methods.\nresults.frequencies()\n</pre> # Check the frequencies, probabilities and sample methods. results.frequencies() Out[26]: <pre>Counter({'10000': 1000})</pre> In\u00a0[27]: Copied! <pre>results.probabilities()\n</pre> results.probabilities() Out[27]: <pre>array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])</pre> In\u00a0[28]: Copied! <pre>results.samples()\n</pre> results.samples() Out[28]: <pre>array([[1, 0, 0, 0, 0],\n       [1, 0, 0, 0, 0],\n       [1, 0, 0, 0, 0],\n       ...,\n       [1, 0, 0, 0, 0],\n       [1, 0, 0, 0, 0],\n       [1, 0, 0, 0, 0]], dtype=int32)</pre> <p>In this example we will dive into quantum teleportation doing first a single teleportation, then several consecutive teleportations and we will end with a network. Find more details at the PDF called \"Teleportation and QuantumNetworks.pdf\".</p> In\u00a0[7]: Copied! <pre>import numpy as np\n\nfrom qibo import Circuit, gates\n\nfrom helper_functions import random_state,print_random_state, print_theoretical_values, print_sampled_values, get_probabilities, execute_get_samples_and_plot, create_networkx_graph, print_networkx_graph, compute_network_path, create_secure_quantum_teleportation_path_circuit\n\n# Number of `shots` we will use during this notebook:\nshots = 10_000\n</pre> import numpy as np  from qibo import Circuit, gates  from helper_functions import random_state,print_random_state, print_theoretical_values, print_sampled_values, get_probabilities, execute_get_samples_and_plot, create_networkx_graph, print_networkx_graph, compute_network_path, create_secure_quantum_teleportation_path_circuit  # Number of `shots` we will use during this notebook: shots = 10_000 <p>Let's generate a <code>random state</code>, for <code>Alice</code>!</p> In\u00a0[8]: Copied! <pre># Generate random state:\ntheta, phi = random_state()\nalpha, beta = np.cos(theta/2), np.sin(theta/2)*np.exp(phi*1.j)*-1.j\nprob_a, prob_b = np.cos(theta/2)**2, np.sin(theta/2)**2\nprint_random_state(theta, phi)\n</pre> # Generate random state: theta, phi = random_state() alpha, beta = np.cos(theta/2), np.sin(theta/2)*np.exp(phi*1.j)*-1.j prob_a, prob_b = np.cos(theta/2)**2, np.sin(theta/2)**2 print_random_state(theta, phi) <pre>Theta: 2.7669934551790796, Phi: -1.9307265208974014\nState: alpha=0.18620640458790377  beta=(-0.9195527538880768+0.3460489961079211j)\nProbabilities: prob_a=0.03467282510955411  prob_b=0.965327174890446\n\n</pre> <p>Now let's do a small <code>circuit</code> and see its <code>results</code> and <code>probabilities</code>:</p> In\u00a0[9]: Copied! <pre># Define a small circuit to check its probabilities:\nc0 = Circuit(1)\nc0.add(gates.U1q(q=0, theta=theta, phi=phi))\nc0.add(gates.M(0))\n\n# Plot the circuit:\nprint(f\"Circuit:\\n{c0.draw()}\\n\")\n\n# Run the circuit:\nresult = c0(nshots=shots)\n\n# Theoretical values:\nstate = result.state()\nprobabilities = result.probabilities()\nprint_theoretical_values(state, probabilities)\n\n# Sampled values (with nshots):\n# (possible because we have a Measurement gate!)\nsamples = np.stack(result.samples(), axis=1)\nfrequencies = result.frequencies()\nsampled_probabilities = get_probabilities(frequencies)\nprint_sampled_values(samples, frequencies, sampled_probabilities)\n</pre> # Define a small circuit to check its probabilities: c0 = Circuit(1) c0.add(gates.U1q(q=0, theta=theta, phi=phi)) c0.add(gates.M(0))  # Plot the circuit: print(f\"Circuit:\\n{c0.draw()}\\n\")  # Run the circuit: result = c0(nshots=shots)  # Theoretical values: state = result.state() probabilities = result.probabilities() print_theoretical_values(state, probabilities)  # Sampled values (with nshots): # (possible because we have a Measurement gate!) samples = np.stack(result.samples(), axis=1) frequencies = result.frequencies() sampled_probabilities = get_probabilities(frequencies) print_sampled_values(samples, frequencies, sampled_probabilities) <pre>[Qibo 0.2.8|INFO|2024-10-04 23:56:09]: Using numpy backend on /CPU:0\n</pre> <pre>Circuit:\nq0: \u2500U1q\u2500M\u2500\n\nTHEORETICAL VALUES:\nState: [ 0.1862064 +0.j       -0.91955275+0.346049j]\nProbabilities: [0.03467283 0.96532717]\n\nSAMPLED VALUES:\nSamples: [[1 1 1 ... 1 1 1]]\nFrequencies: Counter({'1': 9643, '0': 357})\nSampled probabilities: {'0': 0.0357, '1': 0.9643}\n</pre> Out[9]: In\u00a0[10]: Copied! <pre># Define teleport circuit\nc = Circuit(3)\n\n# Initial Alice random state\nc.add(gates.U1q(q=0, theta=theta, phi=phi))\n\n# Initial Alice-Bob entangled state\nc.add(gates.H(1))\nc.add(gates.CNOT(1,2))\n\n# Entanglement measure of Alice\nc.add(gates.CNOT(0,1))\nc.add(gates.H(0))\nc.add(gates.M(0))\nc.add(gates.M(1))\n\n# From Alice's results, Bob does control Z's &amp; X's:\nc.add(gates.CZ(0,2))\nc.add(gates.CNOT(1,2))\nc.add(gates.M(2, register_name=\"measure\"))\n\n# Plot the circuit:\nprint(f\"Circuit:\\n{c.draw()}\\n\")\n</pre> # Define teleport circuit c = Circuit(3)  # Initial Alice random state c.add(gates.U1q(q=0, theta=theta, phi=phi))  # Initial Alice-Bob entangled state c.add(gates.H(1)) c.add(gates.CNOT(1,2))  # Entanglement measure of Alice c.add(gates.CNOT(0,1)) c.add(gates.H(0)) c.add(gates.M(0)) c.add(gates.M(1))  # From Alice's results, Bob does control Z's &amp; X's: c.add(gates.CZ(0,2)) c.add(gates.CNOT(1,2)) c.add(gates.M(2, register_name=\"measure\"))  # Plot the circuit: print(f\"Circuit:\\n{c.draw()}\\n\") <pre>Circuit:\nq0: \u2500U1q\u2500\u2500\u2500o\u2500H\u2500M\u2500o\u2500\u2500\u2500\u2500\u2500\nq1: \u2500H\u2500\u2500\u2500o\u2500X\u2500M\u2500\u2500\u2500|\u2500o\u2500\u2500\u2500\nq2: \u2500\u2500\u2500\u2500\u2500X\u2500\u2500\u2500\u2500\u2500\u2500\u2500Z\u2500X\u2500M\u2500\n\n</pre> In\u00a0[11]: Copied! <pre>execute_get_samples_and_plot(circuit=c, shots=shots)\n</pre> execute_get_samples_and_plot(circuit=c, shots=shots) <pre>SAMPLED VALUES:\nSamples: [[1 1 1 ... 1 1 1]]\nFrequencies: Counter({'1': 9655, '0': 345})\nSampled probabilities: {'0': 0.0345, '1': 0.9655}\n</pre> Out[11]: In\u00a0[12]: Copied! <pre>edges = {\n    (\"Guille\", \"David\"): \"\",\n    (\"David\", \"Jacobo\"): \"\",\n}\nG = create_networkx_graph(edges)\nprint_networkx_graph(G, edges)\n</pre> edges = {     (\"Guille\", \"David\"): \"\",     (\"David\", \"Jacobo\"): \"\", } G = create_networkx_graph(edges) print_networkx_graph(G, edges) <p>Now, lets do the <code>circuit</code>. Notice its the same, but with everything <code>duplicated</code>!</p> In\u00a0[13]: Copied! <pre># Define teleport circuit\nc = Circuit(5)\n\n# Initial Alice random state\nc.add(gates.U1q(q=0, theta=theta, phi=phi))\n\n# Initial entangled states:\nc.add(gates.H(1))\nc.add(gates.CNOT(1,2))\n\nc.add(gates.H(3))\nc.add(gates.CNOT(3,4))\n\n# Entanglement measurements\nc.add(gates.CNOT(0,1))\nc.add(gates.H(0))\nc.add(gates.M(0))\nc.add(gates.M(1))\n\nc.add(gates.CNOT(2,3))\nc.add(gates.H(2))\nc.add(gates.M(2))\nc.add(gates.M(3))\n\n# From the obtained results, we do control Z's and X's to Bob:\nc.add(gates.CZ(0,4))\nc.add(gates.CNOT(1,4))\n\nc.add(gates.CZ(2,4))\nc.add(gates.CNOT(3,4))\n\nc.add(gates.M(4, register_name=\"measure\"))\n\n# Plot the circuit:\nprint(f\"Circuit:\\n{c.draw()}\\n\")\n</pre> # Define teleport circuit c = Circuit(5)  # Initial Alice random state c.add(gates.U1q(q=0, theta=theta, phi=phi))  # Initial entangled states: c.add(gates.H(1)) c.add(gates.CNOT(1,2))  c.add(gates.H(3)) c.add(gates.CNOT(3,4))  # Entanglement measurements c.add(gates.CNOT(0,1)) c.add(gates.H(0)) c.add(gates.M(0)) c.add(gates.M(1))  c.add(gates.CNOT(2,3)) c.add(gates.H(2)) c.add(gates.M(2)) c.add(gates.M(3))  # From the obtained results, we do control Z's and X's to Bob: c.add(gates.CZ(0,4)) c.add(gates.CNOT(1,4))  c.add(gates.CZ(2,4)) c.add(gates.CNOT(3,4))  c.add(gates.M(4, register_name=\"measure\"))  # Plot the circuit: print(f\"Circuit:\\n{c.draw()}\\n\") <pre>Circuit:\nq0: \u2500U1q\u2500\u2500\u2500\u2500\u2500\u2500\u2500o\u2500H\u2500M\u2500\u2500\u2500\u2500\u2500\u2500\u2500o\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nq1: \u2500H\u2500\u2500\u2500o\u2500\u2500\u2500\u2500\u2500X\u2500M\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500|\u2500o\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nq2: \u2500\u2500\u2500\u2500\u2500X\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500o\u2500H\u2500M\u2500|\u2500|\u2500o\u2500\u2500\u2500\u2500\u2500\nq3: \u2500\u2500\u2500\u2500\u2500\u2500\u2500H\u2500o\u2500\u2500\u2500\u2500\u2500\u2500\u2500X\u2500M\u2500\u2500\u2500|\u2500|\u2500|\u2500o\u2500\u2500\u2500\nq4: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500X\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500Z\u2500X\u2500Z\u2500X\u2500M\u2500\n\n</pre> In\u00a0[14]: Copied! <pre>execute_get_samples_and_plot(circuit=c, shots=shots)\n</pre> execute_get_samples_and_plot(circuit=c, shots=shots) <pre>SAMPLED VALUES:\nSamples: [[1 1 1 ... 1 1 1]]\nFrequencies: Counter({'1': 9661, '0': 339})\nSampled probabilities: {'0': 0.0339, '1': 0.9661}\n</pre> Out[14]: In\u00a0[15]: Copied! <pre># Our secure quantum teleportation network is:\nedges = {\n    (\"guille\",\"MAD\"): \"&lt;--&gt;\",\n    (\"david\",\"MAD\"): \"\",\n    (\"jacobo\",\"MAD\"): \"\",\n    (\"...\", \"MAD\"): \"\",\n    (\"arnau\", \"BCN\"): \"\",\n    (\"ameer\", \"BCN\"): \"&lt;--&gt;\",\n    (\"enrique\", \"BCN\"): \"\",\n    (\"....\", \"BCN\"): \"\",\n    (\"BCN\", \"MAD\"): \"&lt;--&gt;\",\n}\ngraph_to_travel = create_networkx_graph(edges)\nprint_networkx_graph(graph_to_travel, edges)\n</pre> # Our secure quantum teleportation network is: edges = {     (\"guille\",\"MAD\"): \"&lt;--&gt;\",     (\"david\",\"MAD\"): \"\",     (\"jacobo\",\"MAD\"): \"\",     (\"...\", \"MAD\"): \"\",     (\"arnau\", \"BCN\"): \"\",     (\"ameer\", \"BCN\"): \"&lt;--&gt;\",     (\"enrique\", \"BCN\"): \"\",     (\"....\", \"BCN\"): \"\",     (\"BCN\", \"MAD\"): \"&lt;--&gt;\", } graph_to_travel = create_networkx_graph(edges) print_networkx_graph(graph_to_travel, edges) <p>Now telling <code>who</code> wants to send a quantum state, and to who, <code>we compute the needed quantum circuit</code>!</p> In\u00a0[16]: Copied! <pre># Guille wants to send a message to ameer:\nsender = \"guille\"\nreceiver = \"ameer\"\n\n# Search for the edges with shortest path\nedges = compute_network_path(graph=graph_to_travel, sender=sender, receiver=receiver)\nprint(f\"The path to follow is: {edges}\")\n\n# Create and plot the neede circuit:\nautomatic_circuit = create_secure_quantum_teleportation_path_circuit((theta,phi), edges)\n\n# Plot the circuit:\nprint(f\"Circuit:\\n{automatic_circuit.draw()}\\n\")\n</pre> # Guille wants to send a message to ameer: sender = \"guille\" receiver = \"ameer\"  # Search for the edges with shortest path edges = compute_network_path(graph=graph_to_travel, sender=sender, receiver=receiver) print(f\"The path to follow is: {edges}\")  # Create and plot the neede circuit: automatic_circuit = create_secure_quantum_teleportation_path_circuit((theta,phi), edges)  # Plot the circuit: print(f\"Circuit:\\n{automatic_circuit.draw()}\\n\") <pre>The path to follow is: [('guille', 'MAD'), ('MAD', 'BCN'), ('BCN', 'ameer')]\nCircuit:\nq0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500U1q\u2500o\u2500H\u2500M\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500o\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nq1: \u2500H\u2500o\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500X\u2500M\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500|\u2500o\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nq2: \u2500\u2500\u2500X\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500o\u2500H\u2500M\u2500\u2500\u2500\u2500\u2500\u2500\u2500|\u2500|\u2500o\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nq3: \u2500\u2500\u2500\u2500\u2500H\u2500o\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500X\u2500M\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500|\u2500|\u2500|\u2500o\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nq4: \u2500\u2500\u2500\u2500\u2500\u2500\u2500X\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500o\u2500H\u2500M\u2500|\u2500|\u2500|\u2500|\u2500o\u2500\u2500\u2500\u2500\u2500\nq5: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500H\u2500o\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500X\u2500M\u2500\u2500\u2500|\u2500|\u2500|\u2500|\u2500|\u2500o\u2500\u2500\u2500\nq6: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500X\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500Z\u2500X\u2500Z\u2500X\u2500Z\u2500X\u2500M\u2500\n\n</pre> In\u00a0[17]: Copied! <pre>execute_get_samples_and_plot(circuit=c, shots=shots)\n</pre> execute_get_samples_and_plot(circuit=c, shots=shots) <pre>SAMPLED VALUES:\nSamples: [[1 1 1 ... 1 1 1]]\nFrequencies: Counter({'1': 9653, '0': 347})\nSampled probabilities: {'0': 0.0347, '1': 0.9653}\n</pre> Out[17]: <p>IT WORKS PERFECTLY!!!</p>"},{"location":"gate-based/intro_to_quantum_solutions/#introduction-to-digital-quantum-computing","title":"Introduction to digital quantum computing\u00b6","text":"<p>Information for challengers: the first steps are the harder ones. In this challenge, you will clean the path for the newcomers by showing them what's a qubit and how to compute combining them. Follow the started structure to find the</p> <p>Sources (Qibo): https://qibogang.github.io/docs/qibo/stable https://qibogang.github.io/tutorials/1_getting-started</p> <p>Sources (not Qibo): https://www.iqmacademy.com/curriculum/foundations02.html https://learning.quantum.ibm.com/course/basics-of-quantum-information/quantum-circuits</p>"},{"location":"gate-based/intro_to_quantum_solutions/#1st-exercise-basic-tutorial","title":"1st exercise: basic tutorial\u00b6","text":"<p>Follow the tutorial from qibo to get familiar with the environment. You can do it in this notebook.</p>"},{"location":"gate-based/intro_to_quantum_solutions/#2nd-exercise-bit-flip","title":"2nd exercise: Bit flip\u00b6","text":"<p>Follow the learnt syntaxis to run a bitflip using qibo.</p> <p>Probably, the most basic operation that we can perform on a qbit is a bitflip. This operation consist on, given any basis state, inverting its value:</p> <p>$$ \\left| 0 \\right&gt; \\rightarrow \\left| 1 \\right&gt;, \\left| 1 \\right&gt; \\rightarrow \\left| 0 \\right&gt;$$</p> <p>Given that we always take meassurements on the Z axis, the bitflip can be applied by performing a simple Pauli X-Gate. This is, a $\\pi$ radian rotation along the X axis.</p> <p></p>"},{"location":"gate-based/intro_to_quantum_solutions/#3rd-exercise-quantum-teleportation","title":"3rd exercise: Quantum teleportation\u00b6","text":""},{"location":"gate-based/intro_to_quantum_solutions/#imports-and-global-variables","title":"Imports and global variables:\u00b6","text":""},{"location":"gate-based/intro_to_quantum_solutions/#1-random-initial-state","title":"1) Random initial state:\u00b6","text":""},{"location":"gate-based/intro_to_quantum_solutions/#2-teleportation-circuit","title":"2) Teleportation circuit:\u00b6","text":"<p>Now we will generate the previously shown <code>circuit</code> for quantum teleportation:</p>"},{"location":"gate-based/intro_to_quantum_solutions/#3-consecutive-quantum-teleports","title":"3) Consecutive quantum teleports:\u00b6","text":"<p>Using an <code>intermediary B</code> we can connect <code>A</code> and <code>C</code>, that have never met before!</p> <p>First lets define the <code>graph</code> for such case:</p>"},{"location":"gate-based/intro_to_quantum_solutions/#4-quantum-teleportation-network","title":"4) Quantum teleportation network:\u00b6","text":"<p>Now lets define a more complicated <code>graph</code> for a possible <code>quantum network</code>:</p>"},{"location":"gate-based/quantum-walks/","title":"Quantum Walks","text":""},{"location":"gate-based/quantum-walks/#summary-classical-random-walks","title":"Summary classical random walks","text":"<p>A random walk is a random process involving a \"walker\" that is placed in some n-dimensional medium, like a grid or a graph. We then repeatedly query some random variable, and based on the outcome of our measurement, the walker's position vector (position on the graph or grid) is updated. A basic example of a random walk is the one-dimensional graphical case, where we consider a marker placed on the origin of a number line with markings at each of the integers. Let the initial position vector of our marker be \\(\\ket{0}\\). For  \\(N\\) steps of our random walk, take a set of  \\(N\\) random variables \\({X_1, \u2026, X_N}\\), which can take on either a value of 1 or -1 with equal probability. To find the updated position vector of our walker, we compute the value:</p> \\[j = \\sum_{k=1}^{N}X_{k}\\] <p>Where we know:</p> \\[\\ket{Final} = \\ket{Initial + j}\\] <p>So for our case, the final position vector is \\(\\ket{j}\\).  For a discrete, 1-dimensional random walk on a number-line-like graph, the probability of the random walker being at a specific location follows a binomial distribution. This binomial distribution arises from the behavior of the walker through the 1-dimensional graph which is modeled by the following distribution:</p> \\[P_{N}(X) \\ = \\ \\begin{pmatrix} N \\\\ R \\end{pmatrix} \\ p_{r}^R (1 \\ - \\ p_{r})^{N \\ - \\ R} \\Rightarrow \\ X \\ = \\ R \\ - \\ L \\ \\Rightarrow \\ P_{N}(X) \\ = \\ \\begin{pmatrix} N \\\\ \\frac{N \\ + \\ X}{2} \\end{pmatrix} \\ p_{r}^{\\frac{N \\ + \\ X}{2} } (1 \\ - \\ p_{r})^{\\frac{N \\ - \\ X}{2} }\\] <p>Where \\(P(X)\\) is the probability of the walker to end up in position \\(X\\), \\(N\\) is the number of total steps taken, \\(p_r\\) is the probability of taking a step to the right and \\(R\\) is the total number of steps taken to the right. If we start from the zero position after many steps, the probability distribution of finding ourselves in a given new position is represented by Figure 1.</p> <p> Figure 1. Binomial distribution for a classical random walk on a 1-dimensional graph.</p>"},{"location":"gate-based/quantum-walks/#quantum-random-walks","title":"Quantum random walks","text":"<p>The process of the quantum walk isn't that much different from its classical counterpart, although the observed results of the two processes have many differences. First, let us motivate the creation of a QW. The idea is that when one performs analysis on a classical random walk, you can find that  \\(\\sigma^2 \\ \\sim \\ T\\), where \\(\\sigma\\) is the standard deviation of the random walk's probability distribution, and \\(T\\) is the number of time-steps of the random walk. For the quantum walk, we can see that \\(\\sigma^2 \\ \\sim \\ T^2\\). In other words, the standard deviation grows at a quadratically faster rate. At a high level, this signifies that the quantum walker \"spreads out\" quadratically faster than the classical one, showing that the process of a QW is quadratically faster than its classical counterpart.</p>"},{"location":"gate-based/quantum-walks/#quantum-walks-for-1-dimensional-ring-graph","title":"Quantum Walks for 1-dimensional ring graph","text":"<p>The objective is to translate the elements present in the classical random walk into the quantum formalism. Given a ring graph for a dimension we want to simulate the classical walk but with the elements of the quantum formalism.</p> <p> </p> <p>Figure 2. 1-dimensional ring graph.</p> <p>Firstly we need to encode the position or the node of the network we are in, but this is quite easy to do, for a \\(k\\)-node network we can form a Hilbert space \\(H_W\\) given by:</p> \\[H_W \\ = \\ \\{\\lvert j\\rangle \\ : \\ j \\ = \\ 0, \\ ..., \\ K \\ - \\ 1 \\}\\] <p>We also require another vector in order to create a random walk. We need a \"coin vector\", which will encode the direction in which the random walk will progress at the \\(T\\)-th step of the process. This Hilbert space is spanned by the two basis states, representing forward and backward progression on our number-line-like graph (actually, our graph looks more like a ring, so the two basis states will represent clockwise and counter-clockwise motion, but it's the same idea). We will call this Hilbert space \\(H_C\\), and we can again define our spanning set:</p> \\[H_C \\ = \\ \\{\\lvert i\\rangle \\ : \\ i \\ = \\ \\downarrow, \\ \\uparrow\\rangle\\}\\] <p>Where the upward-arrow symbol represent counter-clockwise motion, and the downward arrow represents clock-wise motion. Now that we have defined all the vectors we need to encode the information about our random walk, we must understand how we can realize these vectors in our quantum algorithm. Well, this is again fairly simple. For a graph of \\(K = 2^n\\)  nodes, we require \\(n\\) qubits to encode binary representations of numbers ranging from \\(0\\) to \\(K-1\\), therefore each of the vectors spanning \\(H_W\\) will be given by the binary representation of \\(j\\) corresponding to the basis vector \\(\\ket{j}\\). For the coin vector, since we have only two states, we only need one qubit to encode the two possible states:</p> \\[\\lvert 0\\rangle \\ = \\ \\lvert \\uparrow\\rangle \\ \\ \\text{and} \\ \\ \\lvert 1\\rangle \\ = \\ \\lvert \\downarrow\\rangle\\] <p>In order to represent the total space of all possible states of our system, we take the tensor product of the two spanning sets, which will then span the new Hilbert space \\(H_C \\otimes H_W\\) . We will write a general element of this Hilbert space as \\(\\ket{i} \\otimes \\ket{j}\\). We define a random walk evolution operator as follows:</p> \\[U \\ = \\ \\lvert \\uparrow\\rangle\\langle\\uparrow\\lvert  \\ \\otimes \\ \\displaystyle\\sum_{j} \\ \\lvert j \\ + \\ 1\\rangle\\langle j\\lvert  \\ + \\ \\lvert \\downarrow\\rangle\\langle\\downarrow\\lvert  \\ \\otimes \\ \\displaystyle\\sum_{j} \\ \\lvert j \\ - \\ 1\\rangle\\langle j\\lvert\\] <p>We also need to define a coin operator that gives the probabilities of moving in one direction or the opposite direction. For the coin operator we define: </p> \\[U_C = H\\] <p>The choice of the Hadamard gate is a natural choice for implementing a fair coin operator. One step within the network is given by the circuit shown below:</p> <p> Figure 3. Quantum walks circuit.</p> <p>The circuit shown is equivalent to the application of operator:</p> \\[S \\ = \\ U \\ (H \\ \\otimes \\ I)\\]"},{"location":"gate-based/quantum-walks/#python-code-experiment","title":"Python code experiment","text":"<p>Required libaries</p> <pre><code>from qibo import gates, models\nfrom matplotlib import pyplot as plt\n</code></pre> <p>We define the operator that implements a quantum walk step which is a combination of the addition operator and the subtraction operator:</p> <pre><code>def walk_step_qibo(circuit, number_qubits):\n    # \"Flip\" the coin vector\n    circuit.add(gates.H(number_qubits))\n\n    # Implement the Addition Operator\n    circuit.add(gates.X(number_qubits))\n\n    for i in range(number_qubits, 0, -1):\n        controls = list(range(number_qubits, i-1, -1))\n        circuit.add(gates.X(i-1).controlled_by(*controls))\n        if i &gt; 1:\n            circuit.add(gates.X(i-1))\n\n    circuit.add(gates.X(number_qubits))\n\n    # Implement the Subtraction Operator\n    for i in range(1, number_qubits + 1):\n        controls = list(range(number_qubits, i-1, -1))\n        circuit.add(gates.X(i-1).controlled_by(*controls))\n        if i &lt; number_qubits:\n            circuit.add(gates.X(i))\n\n    return circuit\n</code></pre> <p>We set the initial state associated with the node of the output graph </p> <pre><code>def initial_state_qibo(circuit, number_qubits):\n    # Initial node\n    circuit.add(gates.X(1))\n\n      # Initial state for coin operator\n    circuit.add(gates.H(number_qubits))\n    circuit.add(gates.S(number_qubits))\n</code></pre> <p>We implement the quantum walk algorithm as the n-times application of the step operator on the initial state</p> <pre><code>def generate_walk_qibo(number_qubits, iterator, sample_number):\n    circuit = models.Circuit(number_qubits + 1)\n    initial_state_qibo(circuit, number_qubits)\n\n    for _ in range(iterator):\n        walk_step_qibo(circuit, number_qubits)  \n\n    for q in range(number_qubits):\n        circuit.add(gates.M(q))\n\n    result = circuit(nshots= sample_number)\n    final = result.frequencies(binary=True)\n    return final\n</code></pre> <p>The final measured distribution represents the final probability of being at each node after n steps</p> <pre><code>number_nodes = 7\nsteps = 30\nsample_number = 5000\n\n\nfinal = generate_walk_qibo(number_nodes, steps, sample_number)\n</code></pre> <p></p>"},{"location":"gate-based/quantum_walks/","title":"Quantum Walks Qibo for 1-dimensional ring graph","text":"In\u00a0[20]: Copied! <pre>from qibo import gates, models\nfrom matplotlib import pyplot as plt\n</pre> from qibo import gates, models from matplotlib import pyplot as plt In\u00a0[8]: Copied! <pre>def plot_distribution(final):\n\n    x_arr = list(final.keys())\n    y_arr = [dict(final)[j] for j in dict(final).keys()]\n\n    x_arr_final = []\n    y_arr_final = []\n\n    while (len(x_arr) &gt; 0):\n\n        x_arr_final.append(min(x_arr))\n        y_arr_final.append(y_arr[x_arr.index(min(x_arr))])\n        holder = x_arr.index(min(x_arr))\n        del x_arr[holder]\n        del y_arr[holder]\n\n    plt.plot(x_arr_final, y_arr_final)\n    plt.scatter(x_arr_final, y_arr_final)\n    plt.gca().set_xticklabels([])\n    plt.show()\n</pre> def plot_distribution(final):      x_arr = list(final.keys())     y_arr = [dict(final)[j] for j in dict(final).keys()]      x_arr_final = []     y_arr_final = []      while (len(x_arr) &gt; 0):          x_arr_final.append(min(x_arr))         y_arr_final.append(y_arr[x_arr.index(min(x_arr))])         holder = x_arr.index(min(x_arr))         del x_arr[holder]         del y_arr[holder]      plt.plot(x_arr_final, y_arr_final)     plt.scatter(x_arr_final, y_arr_final)     plt.gca().set_xticklabels([])     plt.show() In\u00a0[11]: Copied! <pre>def walk_step_qibo(circuit, number_qubits):\n    # \"Flip\" the coin vector\n    \n    circuit.add(gates.H(number_qubits))\n\n    # Implement the Addition Operator\n    \n    circuit.add(gates.X(number_qubits))\n\n    for i in range(number_qubits, 0, -1):\n        controls = list(range(number_qubits, i-1, -1))\n        circuit.add(gates.X(i-1).controlled_by(*controls))\n        if i &gt; 1:\n            circuit.add(gates.X(i-1))\n\n    circuit.add(gates.X(number_qubits))\n\n    # Implement the Subtraction Operator\n    \n    for i in range(1, number_qubits + 1):\n        controls = list(range(number_qubits, i-1, -1))\n        circuit.add(gates.X(i-1).controlled_by(*controls))\n        if i &lt; number_qubits:\n            circuit.add(gates.X(i))\n\n    return circuit\n</pre> def walk_step_qibo(circuit, number_qubits):     # \"Flip\" the coin vector          circuit.add(gates.H(number_qubits))      # Implement the Addition Operator          circuit.add(gates.X(number_qubits))      for i in range(number_qubits, 0, -1):         controls = list(range(number_qubits, i-1, -1))         circuit.add(gates.X(i-1).controlled_by(*controls))         if i &gt; 1:             circuit.add(gates.X(i-1))      circuit.add(gates.X(number_qubits))      # Implement the Subtraction Operator          for i in range(1, number_qubits + 1):         controls = list(range(number_qubits, i-1, -1))         circuit.add(gates.X(i-1).controlled_by(*controls))         if i &lt; number_qubits:             circuit.add(gates.X(i))      return circuit In\u00a0[12]: Copied! <pre>def initial_state_qibo(circuit, number_qubits):\n    \n    circuit.add(gates.X(1))\n    \n    circuit.add(gates.H(number_qubits))\n    circuit.add(gates.S(number_qubits))\n</pre> def initial_state_qibo(circuit, number_qubits):          circuit.add(gates.X(1))          circuit.add(gates.H(number_qubits))     circuit.add(gates.S(number_qubits)) In\u00a0[17]: Copied! <pre>def generate_walk_qibo(number_qubits, iterator, sample_number):\n    \n    circuit = models.Circuit(number_qubits + 1)\n\n    initial_state_qibo(circuit, number_qubits)\n\n    for _ in range(iterator):\n        walk_step_qibo(circuit, number_qubits)  \n\n    for q in range(number_qubits):\n        circuit.add(gates.M(q))\n\n    result = circuit(nshots= sample_number)\n    final = result.frequencies(binary=True)\n\n    return final\n</pre> def generate_walk_qibo(number_qubits, iterator, sample_number):          circuit = models.Circuit(number_qubits + 1)      initial_state_qibo(circuit, number_qubits)      for _ in range(iterator):         walk_step_qibo(circuit, number_qubits)        for q in range(number_qubits):         circuit.add(gates.M(q))      result = circuit(nshots= sample_number)     final = result.frequencies(binary=True)      return final In\u00a0[18]: Copied! <pre>number_nodes = 7\nsteps = 30\nsample_number = 5000\n\n\nfinal = generate_walk_qibo(number_nodes, steps, sample_number)\n</pre> number_nodes = 7 steps = 30 sample_number = 5000   final = generate_walk_qibo(number_nodes, steps, sample_number) In\u00a0[21]: Copied! <pre>plot_distribution(final)\n</pre> plot_distribution(final)"},{"location":"gate-based/quantum_walks/#quantum-walks-qibo-for-1-dimensional-ring-graph","title":"Quantum Walks Qibo for 1-dimensional ring graph\u00b6","text":""},{"location":"gate-based/quantum_walks/#library","title":"Library\u00b6","text":""},{"location":"gate-based/quantum_walks/#auxiliar-function","title":"Auxiliar function\u00b6","text":""},{"location":"gate-based/quantum_walks/#quantum-walks-qibo-circuit","title":"Quantum Walks Qibo Circuit\u00b6","text":""},{"location":"gate-based/quantum_walks/#example-quantum-walks-over-1-dimensional-ring-graph","title":"Example Quantum Walks over 1-dimensional ring graph\u00b6","text":""},{"location":"qpus/analog1/","title":"First Qilichip","text":"<p>That's the first chip</p>"},{"location":"qpus/analog2/","title":"Our second Analog chip","text":"<p>Look how beautiful it is!</p>"},{"location":"qpus/qpus/","title":"QPUs","text":"<p>Section about our QPUs</p>"}]}